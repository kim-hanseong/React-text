//*** useReducer ***
//*  useReducer 는 useState의 심화버전으로 볼 수 도 있다. state와 비슷한 형태를 띄지만 좀 더 복잡한 상태값을 미리 정할 수 있다. *

//* useReducer 사용법 *

//* A. 반환값은 useState와 동일하게 길이가 2인 배열이다 *
//* :state : 현재값을 의미한다 useState 와 마찬가지로 배열을 반환하는데 동일하게 첫번째요소가 이 값이다 *
//* :dispatcher : state를 업데이트 하는 함수, useReducer가 반환하는 두번째 요소이다 useReducer에선 값을 넘겨주는것이 아닌 action 을 넘겨준다. *

//* B. useState의 인수와 달리 2개에서 3개의 인수를 필요로 한다 *
//* :reducer : useReducer의 기본 action 을 정의하는 함수다 이건 첫번째 인수로 넘겨줘야한다. *
//* :initialstate : 두번째 인수로 useReducer의 초깃값을 의미한다. *
//* :init : useState의 인수로 함수를 넘겨줄 때 처럼 초깃값을 지연해서 생성시키고 싶을 때 사용하는 함수다 이건 필수값이 아니며 인수로 넘겨주는 함수가 존재한다면 게으른 초기화가 일어나 두번째 인수로 init 함수가 실행된다.  *
//* 대충 세번째 인수를 넣으면 함수 호출까지 값이 안나온다는 뜻- / *

//* p.226 *
//* useReducer의 목적은 가능하다 *
//* 복잡한 형태의 usestate 를 사전에 정의된 dispatcher 로 만  수정할 수 있게 만들어 놓고 이 방법을 컴포넌트 밖에다 둔 다음 *
//* 업데이트를 미리 정의해 둔 dsipatcher로만 제한하는것 state값을 변경하는 시나리오를 제한해두고 변경을 빠르게 확인할 수 있게끔 하는것이 useReducer 이다. *
//* 대충 useState에 나오는 값들을 액션으로 따로 줄 수 있고 시나리오 자체를 제한해 정리와 편의성을 돕는 훅이라고 생각한다. *

//*** useReducer는 어떻게 구현되어있는가 ? ***
//* p.228 *
//* A. useState로 구현하려면 첫 번째 인수는 업데이트하는 함수 이거나 값 그 자체여야한다 *
//* B. 두번째 인수는 초깃값이기 때문에 별 다른 처리를 할 필요가 없다 세번째 값은 두번째를 기반으로 게으른 초기화를 하기때문이다.  *
//* (세번째 값에서 두번째 인수가 함수면 실행하고 함수가 아니라면 그 값을 업데이트 하는 함수로 만들어야한다.) *
