//*** 랜더링이 일어나는 경우 ***
//* react 에서의 랜더링이란 props 와 state 가 DOM의 결과에 따라 어떤 결괏값을 갖게 되는지 계산하는 일련의 과정이다. *

//* 컴포넌트가 랜더링이 일어나는 이유 *
//* 1. 최초랜더링 처음 애플리케이션에 진입 하면 결과물이 필요하기에 최초 랜더링을 실행한다 *
//* 2. setState가 실행될때 : setState 호출을 통해 컴포넌트를 완성하기 때문에 (class 컴포넌트만) *
//* 3. 함수형 컴포넌트 useState() 의 두번째 배열 요소인 setter 가 실행되는 경우 *
//* 4. 함수형 컴포넌트 useReducer()의 두번째 배열 요소인 dispatch 가 실행되는 경우 함수를 배열로 제공하기에 랜더링이 일어난다 *
//* 5. 하위 컴포넌트위 key 요소가 변경될 때  *
//* 6. 부모 컴포넌트가 리랜더링 된다면 자식 컴포넌트도 무조건 리랜더링이 된다 . *
//※※※ key를 꼭 써야하는 이유 : 동일한 형제 코드에서 서로 구별시켜주기 위한 요소 고로 key 의 변화는 자식 컴포넌트의 변화를 의미하기에 리랜더링이 일어난다. ※※※

//* rhfh react 패키지를 설치가 필수인 이유 결국 리액트의 리랜더링을 발생시키기 위해서 *

//*** 랜더링 프로세스 ***
//* 랜더링이 일어나는 과정은 랜더링 프로세스가 시작되면 리액트는 컴포넌트 루트에서부터 차근차근 아래로 내려가며 업데이트가 필요하다 느끼는 모든 컴포넌트를 찾는다. *
//* 랜더링이 필요하다 느끼는 경우 FunctioComponenet()를 호출한 뒤 그 결과물을 저장한다. *
//* 랜더링 프로세스가 일어나면 각 랜더링 결과물을 수집한 후 리액트의 가상DOM 과 실제DOM의 반영하기 위한 모든 사항을 수집한다. *

//*** 랜더와 커밋 ***

//※※※ 랜더 단계 ※※※
//* : 컴포넌트를 랜더링하고 변경사항을 계산하는 모든작업 *
//* : 가상 DOM 과 비교해 변경이 필요한 컴포넌트를 체크하는 단계이다 이곳에서 크게 비교하는건 TYPE , PROPS , KEY 다 이 세가지중 하나라도 변경되면 체크 해 둔다.*

//※※※ 커밋 단계 ※※※
//* : 랜더 단계의 변경사항을 실제 DOM 에 적용해 사용자에게 보여주는 과정을 말한다. *
//* : 이 단계가 끝나야 비로소 브라우저의 랜더링이 발생된다. *

//* 알 수 있는 사실은 리액트의 랜더링이 일어난다고 무조건 DOM 업데이트가 일어나는것은 아니라는 것. *
//* 랜더 단계에서 변경사항을 감지 할 수 없다면 커밋 단계가 생략되어 브라우저의 DOM 업데이트가 일어나지 않을 수 있다. *

//* 리액트의 랜더링은 항상 동기식으로 작동한다. *
//* 랜더링이 비동기로 일어난다면 사용자는 하나의 상태에 대해 여러가지 다른 UI 를 보게 될 수 있기에 동기로 줘야한다. *
//* 하지만 비동기 REACT 가 의미 있을 수 있는데 특정 랜더링의 우선순위를 낮추거나 , 필요하면 리랜더링 , 경우에 따라선 포기 할 수 있다. *

//* P.180 *
//* 컴포넌트를 랜더링 하는 작업은 별도로 랜더링을 피하기 위한 조치를 하지않는 이상 하위 모든컴포넌트에 영향을 준다 * (10.)
//* 부모가 변경되었다면 PROPS 와 관계없이 무조건 자식 컴포넌트도 리랜더링 된다. *
//* p.181 *
//* memo 로 래핑을 한다면 B 컴포넌트에서 랜더링이 일어나도 D 는 일어나지않는다 *
//* 랜더단계에서 비교를 거쳤지만 memo로 선언한 덕에 커밋단계가 일어나지않는다 *

//*** 정리 ***
//* react 는 불필요한 랜더링이 자주 일어난다 고로 성능 좋은 애플리케이션을 만들려면 불필요한 랜더링 횟수를 줄이는것이 상책이다 *

