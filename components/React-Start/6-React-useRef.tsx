//*** useRef ***
//* useRef 는 useState 와 동일하게 컴포넌트 내부에서 랜더링이 일어나도 변경 가능한 상태값을 저장한다. *
//* 그러나 큰 차이점 두개가 있다. *
//* 1. useRef는 반환값인 객체 내부에 있는 current 값에 접근 또는 변경할 수 있다. *
//* 2. useRef는 값이 변하더라도 랜더링을 발생시키지 않는다 . *
//* 단순하게 말하면 변동성 없이 기본값 지키는 === useRef *

//* p.216 *
//* 그렇다면 외부에서 변수를 선언 하는것이 낫지 않는가 ? *
//* : 의 방식의 단점은 *
//* 1. 컴포넌트의 랜더링 전에 value 라는 값이 기본적으로 존재하게 되어 메모리에 불필요한 값을 갖게 하는 악영향을 미친다. *
//* 2. 컴포넌트가 여러번 재생성이 되었을때 초기화 값이 없다. *

//* useRef는 다르다 *
//* 컴포넌트가 랜더링 될 때만 생성되며 *
//* 컴포넌트 인스턴스가 여러 개라 도 각각 별개의 값을 바라본다. *

//* useRef의 대표적인 예시는 DOM에 접근하고 싶을 때 일것이다. *

//* p.217 *
//* useRef는 최초에 넘겨받은 기본값을 가지고 있다 *
//* 이 useRef는 랜더링이 실행되기 전은 undifined 값을 가지고 있지만 *
//* 해당 페이지가 랜더링이 시작되고 그 ref 의 인수값을 전달 해 준다면 그 인수값을 기반으로 생성된다. *
//* ex) p.217 에서 useEffect 로 log 를 찍을때 input 이 나오는 이유가 그것 *

//* useRef를 사용할 수 있는 경우는 랜더링을 발생시키지 않고 원하는 상태값을 저장할 수 있다는 특징을 활용해 *
//* useState의 이전 값을 저장하는 uesPrevious 같은 훅을 구현할 때다. *

//* p.218 *
//* 처럼 useRef를 이용하면 원하는 시점의 값을 랜더링에 영향을 미치지 않고 보관할 수 있다. *

//* useRef의 구현 *
//* useRef 는 값이 변경돼도 랜더링되면 안된다는 점 때문에 useMemo에 의도적으로 빈 배열을 선언한다 *
//* useRef는 값을 변경해도 객체를 가르키는 주소가 변경되지 않는다는점 덕분에 구현 할 수 있다. *

//* 처음 호출될 때 빈배열  *

//* js 는 마운트 될 때 그냥 포함시키니까 이전값 호출이 안되는거 아님 *