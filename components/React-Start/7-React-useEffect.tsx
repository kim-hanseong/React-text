//*** useEffect ***
//* useEffect 는 인수를 두개 받는다 첫 번째는 콜백 두번째는 의존성 배열이다 이 두번째 의존성 배열이 변동이 일어나면 첫번째 인수인 콜백을 실행한다. *
//* 두번째 인수에 빈 배열을 넣는다면 화면이 마운트 될 때만 실행이 된다. *

//* useEffect는 동기적으로 부수 효과를 만드는 메커니즘이다 .*
//* 또한 이 부수효과가 언제 일어나는지 보다 어떤 상태값과 함께 실행되는지 살펴보는게 중요하다. *
//* useEffect 는 어떻게 의존성 배열이 변경된 걸 알고 실행되는걸까 ? *
//* 한가지 기억해야하는 사실은 함수형 컴포넌트는 매번 함수를 실행해 랜더링을 수행한다는 것이다. *
//* useEffect 는 바인딩, 옵저버 같은 특별한 기능이 있는것이 아닌 랜더링 할때마다 의존성에 있는 값을 보며 전과 후의 비교를 하고 다르면 실행하는 평범한 부수 효과 함수이다 .*

//* p.199  - 201*
//* 클린업 함수는 return 기준으로 변화가 생기기 전으로 실행하며 이벤트를 추가하고 return 안에 제거를 하는 이유는 *
//* 의존성 배열에 의해 계속 이벤트를 추가 생성하기에 그걸 방지하기 위험을 클린업 함수라고 하며 언마운트 보단 함수형 컴포넌트가 리랜더링 되었을 때 그 전 값을 참조해 실행되기에 다르다 *

//* 의존성 배열 *
//* useEffct 에겐 의존성 배열이라는 부분이 있는데 이곳이 리랜더링을 결정한다 봐도 무방하다 *
//* 처음 빈 배열을 넘겨준다면 해당 객체는 더 이상 리랜더링이 필요없음을 느끼며 화면이 처음 마운트 될 때만 실행되고 그 후는 실행되지 않는다 *
//* 그렇다면 useEffect를 빈 배열로 사용하는건 의미가 없지 않는가 ? *
//* 라고 생각 할 수 있지만 차이점이 분명히 있다 *
//* 1. useEffect 는 클라이언트 서버에서 실행되는것을 무조건 보장하며 window 객체의 접근에 의존하는 코드를 사용해도 된다 . *
//* 2. useEffect 는 부수효과 즉 모든 랜더링이 완료된 이후 실행된다 . (API 데이터를 받아 온 후 실행) 다만 직접실행은 다르다 랜더링이 되는 도중에 실행되기에 1번과 달리 서버에서도 실행된다 하지만 이건 (직접실행 what- ?) *
//* 함수형 컴포넌트를 지연하는 방법이기에 지양한다 . *

//* useEffect 의 실행모습  *
//* A. 이전 훅 정보가 있는지 확인한다 *
//* B. 변경되었는지 확인 이전 값이 있다면 이전 값을 얕은 비교로 비교해 변경이 일어났는지 확인 >> 이전 값이 없다면 최초 실행이므로 변경이 일어난 것으로 간주해 실행을 유도 *
//* C. 변경이 일어났다면 첫번째 인수인 콜백 함수를 실행 *
//* D. 의존성 훅에 다시 저장 *
//* E. 다음 훅이 일어날 때를 대비하기 위해 index 추가 *

//* useEffect는 반드시 의존성 배열로 전달한 값의 변경에 의해 실행돼야 하는 훅이다 그러나 의존성 배열을 넘기지 않은 채 콜백 함수 내부에서 특정 값을 사용한다든것은 실제로 관찰해 사용되는 값과다르게 작동하는걸 의미한다. *
//* 대충 props 와  effect 가 개별사용 된다. *
//* 빈 배열이 사용되어야 하는지 다시 한번 알아봐야하며 빈배열이 아닐때도 메모제이션을 사용하거나 적당한 실행위치를 다시 한번 고민해보는것이 좋다 *

//※※※ useEffect 사용법 ※※※
//* 1. 첫번째 인수에 함수명을 부여해라 *
//* : useEffec 의 사용법이나 사용 수 가 적다면 상관이 없지만 어떤 함수인지 한번에 알아 볼 수 있기위해 만들어 놓는것이 좋다 *
//* 2. 거대한 useEffect 를 만들지마라  *
//* : useEffect 는 의존성 배열을 바탕으로 랜더링 시 의존성이 변경될 때 마다 부수효과를 실행한다 파일의 크기가 커질수록 에플리케이션 성능에 악 영향을 미친다 어쩔 수 없이 큰 useEffec 를 만들어야한다면 의존성 배열을 잘개 쪼게서 사용해라 *
//* 비동기 또한 불가능하다 마운트 될 때 서로의 호출 시간이 다르다면 원했던 값이 들어오지 않게 될 상황이 있기 때문이다. *
//* 실행은 가능하지만 클린업 함수 전에 삭제를 하고 실행시켜야함 *







// import React, { useEffect } from 'react';


// function User({ user, onRemove, onToggle }) {
//   useEffect(() => {
//     console.log('컴포넌트가 화면에 나타남');
//     return () => {
//       console.log('컴포넌트가 화면에서 사라짐');
//     };
//   }, []);
//   return (
//     <div>
//       <b
//         style={{
//           cursor: 'pointer',
//           color: user.active ? 'green' : 'black'
//         }}
//         onClick={() => onToggle(user.id)}
//       >
//         {user.username}
//       </b>
//       &nbsp;
//       <span>({user.email})</span>
//       <button onClick={() => onRemove(user.id)}>삭제</button>
//     </div>
//   );
// }

// function UserList({ users, onRemove, onToggle }) {
//   return (
//     <div>
//       {users.map(user => (
//         <User
//           user={user}
//           key={user.id}
//           onRemove={onRemove}
//           onToggle={onToggle}
//         />
//       ))}
//     </div>
//   );
// }

// export default UserList;

// use Effct 는 대부분 화면이 처음 마운트(등장) 할 때 쓰입니다 .
// 대표적인 예시로는 외부 api 요청 , 라이브러리 사용 등 처음 함수로 가져와야하는 값들은 useEffect 를 사용해서 가져와야합니다.
// 그리고 useEffect 는 마지막에 [] 빈 배열을 써야하는데 이것이 의존성 배열입니다.
// 예를 들어 useState [test , setTest] = useState() 가 있으며
// const [data, setData] = useState<ApiBookData[]>([]);
// // Modal
// const { isOpen, onOpen, onOpenChange } = useDisclosure();
// //  SupaBase Read
// useEffect(() => {
//     ReadSupaBase().then(({ data: record, error }) => {
//         if (error) {
//             console.error("Error fetching data:", error);
//         } else {
//             setData(record as ApiBookData[]);
//         }
//     });
// }, [data]);
// 이렇게 되어있다면 data 의 변동이 일어날때마다 useEffect 는 다시 마운트 하여 최신 상태로 상태값을 유지합니다.
// 대충 빈 배열이면 새로고침을 하지 않는 이상 리랜더링이 일어나지않으며 최신상태로 유지하려면 기존 html 상태와 비슷한 상태에 놓이게 됩니다.
