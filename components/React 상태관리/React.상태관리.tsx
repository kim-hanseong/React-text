//*** React 상태관리 ***

//* 가장 기본적인 방법 useStaet , useReducer *
//* p.349 *
//* 훅 안에 0이라는 외부에서 받아온 값을 0으로 초기값으로 상태를 관리해 숫자를 1씩 증가시킬 수 있게 구현했다. *

//* 여러 컴포넌트가 동일 한 counter 상태를 바라보게 하기 위한 방법 ? *
//* state의 값을 전역상태로 만들어 컴포넌트가 사용하는 모든 훅이 동일한 값을 참조할 수 있게 하려면 방법이  *
//* state의 값을 밖으로 꺼내는 것이다 *
//* p.353  *
//* 예재를 보면 Count 1, 2를 각 컴포넌트에 사용하는 대신 상위 컴포넌트에서만 함수를 사용하고 *
//* 이 반환값을 props 로 하위 요소에 전달하여 창조해 재사용이 가능하게끔 만들었다 *
//* 하지만 이것은 조금 불편해 보이는 이유가 있다 *
//* props 형태로  컴포넌트에 전달해야한다는것이다.. *

//* useState의 상태를 밖으로 분리하기 *
//* useState의 단점은 명확하다 해당 컴포넌트에만 사용이 가능하다는 이야기이다 . *
//* 그럼 완전 밖에서 초기화 해서 관리하면 어떻게 되는가 ? > 오류남 이거  *
//* 왜 오류나냐면 리랜더링이 되지 않기 때문임  *
//* 새로운 상태를 사용하려면 UI 에 보여주기 위해선 반드시 리랜더링이 필요하다 함수형 컴포넌트의 재실행은 컴포넌트 안이라면 많지만 *
//* 외부에선 리랜더링을 해줄 수 있는 장치가 없기 때문이다. *

//* p.355 *
//* 이 예제로 만들면 문제가 생긴다 왜 why ? *
//* 아니 강제로 전역변수 값을 참조시켜야하는데 이게 1, 2 둘다 같은 값을 참조해야하니까 오류가 날 수 밖에 없지..  *

//* 위 시행착오를 통해 다음과 같은 결론에 도출 될 수 있다 .  *
//* 컴포넌트 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야 한다. *
//* 모든 컴포넌트에서 동일시 하게 작동해야된다 . *
//* 타 컴포넌트의 리랜더링이 다른 컴포넌트 랜더링에 영향을 줘선 안된다 . *

//* p.357 *
//* 방법을 알아보자- *
//* get 은 항상 최신값을 가져와야 하므로 함수로 구현햇다. *
//* set 형태는 useState와 동일하게 값 또는 함수를 받을 수 있도록 만들었다 *

//* api에 모아서 사용한다 했을 때 *

 
//*** 04-02 ***
//* redux 상태관리 *
// 웹 사이트가 커질수록, 또 복잡해질수록 이런 상태들은 점점 많아지고, 또 서로 의존하게되며 관리하기 어려워진다.
// 
// 단순히 인스타그램의 내 피드에만 들어가봐도, 정말 많은 상태들이 관리되고 있는 것을 알 수 있다.
// 
// 내 인스타 아이디, 내가 팔로잉하는 사람들 수, 나의 팔로워 수, 내 피드에 공유된 포스트들, 스토리들, 알림 등.. 정말 많다.
// 
// 이런 상태들은 일관적이어야한다. 어떤 말이냐면, 서로 다른 컴포넌트에서 동일한 상태를 다룬다면, 그 출처가 같아야한다는 것이다. 
// 
// 예를 들어, 인스타 피드에 공유된 포스트들을 보여주는 컴포넌트가 있고, 그 포스트들의 개수를 나타내주는 컴포넌트가 있다고 하자.
// 
// 두 가지 컴포넌트 모두 결국 "내가 올린 포스트"라는 데이터를 가져와 사용한다. 그런데 만약에 내가 새로운 포스트를 하나 올렸다고 하자. 그런데 피드에 보여지는 포스트는 11개인데, 그 개수를 나타내는 컴포넌트는 10개를 나타낸다면, 나는 혼란을 느낄 것이다.
// 
// "제대로 올라간게 맞나?!! 뭘 믿어야하지?!"
// 
// 그렇기 때문에 상태의 일관성, 즉 데이터의 무결성은 정말 중요하다.
// 
// 만약 서로 다른 여러개의 컴포넌트들이 어떤 동일한 상태를 다루면, 그 데이터의 정확성을 보장하기 위해 데이터의 변경을 제한해 데이터의 상태를 항상 같게 유지해야한다. 이런 데이터의 무결성을 위해 Single source of Truth(신뢰할 수 있는 단일 출처, 즉 동일한 데이터는 항상 같은 곳에서 데이터를 가지고 온다)라는 방법론이 생기기도 했고, React에서도 이 방법론을 택해서 사용하고 있다. 우리가 useState를 통해서만 state를 변경시켜야하는 이유를 여기에서 추측할 수 있다.
// 
// ! 결국은 동일성을 위한 상태관리를 해야한다는 것. 장바구니 구매 와 바로구매 리스트가 같아야한다는뜻 

//* 상태의 종류 *
//  상태는 크게 전역상태 , 컴포넌트 간 상태 , 지역상태 세가지로 나눌 수 있다.

// 지역상태 : 특정 컴포넌트 안에서만 관리되는 상태를 뜻한다. 다른 컴포넌트들과 데이터를 공유하지 않는다. 예를 들면, input, selectbox 등에서 사용자의 입력값을 받는 경우가 있다

// 컴포넌트 간 상태 : 여러가지 컴포넌트에서 관리되는 상태를 나타낸다. 
// 다수의 컴포넌트에서 쓰이고, 또 영향을 미치는 상태를 뜻한다. 프로젝트 곳곳에서 쓰이는 모달을 예로 들 수 있다. 보통 상위 컴포넌트에서 하위 컴포넌트로 prop을 넘겨 해당 컴포넌트까지 전달되도록 하는 Prop Drilling 방식을 필요로 한다

// 전역상태 : 프로젝트 전체에 영향을 끼치는 상태이다. 예를 들면, 유저 기능을 생각하면 된다. 이 또한 Prop Drilling 방식을 활용해서 부모에서 자식으로 데이터를 전달한다.

//* 상태관리가 필요한 이유 *
// 서로 다른 두 컴포넌트에 같은 데이터가 필요하다 할 때 컴포넌트가 부모자식 관계로 되어있지 않은 이상 각 컴포넌트간 직접적인 데이터 전달이 어렵기 때문이다

//* 여러가지 상태관리를 위한 툴 *

//* 1. ContextApi *
// https://ko.legacy.reactjs.org/docs/context.html

// React 컴포넌트 트리 안 전역상태를 공유할 수 있도록 만들어진 방법이다.

// "전역 상태관리 도구"라고 말하기는 살짝 애매한 감이 있는데, 이는 Context API는 아무것도 관리하지 않기 때문이다. 
// 
// Context API는 종속성을 주입하기위한 도구일 뿐이다. React에서의 실질적인 상태관리는 useState, useReducer를 통해 일어난다.
// 
// 보통 "상태관리" 라고 함은, 변화하는 데이터들을 관리하는 것인데, 상태의 초기 값을 저장하거나, 현재 상태의 값을 읽거나, 새로운 데이터로 상태를 업데이트 하는 등의 행위를 뜻한다. 하지만 Context는 이런 상태들을 직접적으로 관리해주지 않고, 단순히 이미 존재하는 상태를 다른 컴포넌트들과 쉽게 공유할 수 있게 해주는 역할을 한다. 
// 
// 이런 Context API는 중간에 있는 Element들에게 props를 넘겨주지 않고도 데이터를 가져다가 사용할 수 있기 때문에 (Prop Drilling을 피할 수 있다.) 테마나 언어 등 전역적으로 쓰이는 데이터들을 사용할 때 자주 쓰인다.
// 
// 다만 Context를 사용하게되면 컴포넌트를 재사용하기가 매우 힘들어지기때문에, 마구 사용하는 건 지양해야한다. 

// Context는 전역 상태를 저장하는 곳이다. Context 내부에 Provider와 Consumer가 정의되어있고, Consumer는 Context를 통해서 상태에 접근이 가능하다. 

// Provider는 전역 상태를 제공하는 역할을 한다. Context에 상태를 제공해서 다른 컴포넌트가 상태에 접근할 수 있도록 도와준다. 제공된 상태에 접근하기 위해서는 Provider 하위에 컴포넌트가 포함되어있어야한다. 보통 모든 컴포넌트에 접근해야하는 상태를 제공하기 위해서는 Root Component (index.js / app.js)에서 Provider를 정의한다.

// Consumer는 제공받은 전역 상태를 받아서 사용하는 역할을 한다. Context는 Consumer 사이에 있는 첫 객체를

//* 2. Redux *
// https://ko.redux.js.org/introduction/getting-started/

// Redux는 전역 상태관리를 위한 도구이며 어플리케이션 전체에 대한 중앙 저장소 역할을 한다.

// Redux는 "자바스크립트 앱을 위한 예측 가능한 상태 컨테이너"

// "액션"이라는 이벤트를 사용해서 어플리케이션의 상태를 우리가 예측 가능한 방식으로 업데이트 할 수 있게 도와준다. 

// Redux는 라이브러리이기 때문에 다양한 UI Framework / Library들과 함께 사용이 가능하다.

// 비단 React 뿐만아니라 Vue나 Vanilla JS 등에서도 사용이 가능하다는 뜻이다. 

// 처음에는 Redux가 React와 어떤 연관성이 있는 라이브러리라고 생각했는데, 별 상관 없다. 그냥 Redux는 모든 자바스크립트 앱을 위한 상태관리 도구일 뿐이다. 헷갈리지 말자!

// 리덕스 라이브러리 : 리액트랑 연결 시켜준다 .
// https://react-redux.js.org/introduction/why-use-react-redux

// Redux 의 역할은 크게 Store , Reducer , Action 이 세가지로 나뉜다.

// store 는 저장소 즉 전역상태를 저장하는 공간이다. 자바 스크립트 객체 형태로 저장되어 있으며 오로지 Reducer 를 통해서만 접근할 수 있다. Redux에서 Store 는 1개만 존재 할 수 있다.

// Action은 Redicer에 보내는 Store에 대한 행동을 정의하는 자바스크립트 객체이다. 우리가 어떤 액션이 들어오는지 그 유형에 따라 이벤트를 처리하는 이벤트 리스너라고 볼 수 있다.
// "이렇게 상태를 변경해줘" 하는 주문서의 역할을 보면 이해가 쉽다 Action을 Reducer 에 전달하기 위해선 dispath 메소드를 사용해야한다 dispath 는 이벤트 트리거 같은 역할임 

// Reducer는 이전 상태와 액션을 받아 다음 상태를 반환하는 역할을 하는 순수 함수이다.
// 이놈의 특별한 점은 이전 상태를 변경하는게 아닌 새로운 상태 객체를 생성해서 반환해야한다는 사실이다.

// Redux 의 강점은 8가지나 더 있다.
// 1. 로컬스토리지에 상태를 영속적으로 저장하고, 시작할 때 다시 불러오는 것에 뛰어나다.
// 
// 2. 상태를 Server에서 미리 채워서, HTML에 담아 Client로 보내고, 앱을 시작할 때 다시 불러오는 것에 뛰어나다.
// 
// 3. 사용자의 액선을 직렬화(Serialize)해서, 상태와 함께 자동으로 버그 리포트에 첨부할 수 있고, 개발자들은 이를 통해 에러를 재현할 수 있다. 
// 
// 4. 액션 객체를 네트워크를 통해 보내면, 코드를 크게 바꾸지 않고도 협업 환경을 구현할 수 있다.
// 
// 5. 코드를 크게 바꾸지 않고도 실행 취소 내역의 관리나 Optimistic Mutations(낙관적인 변경)을 구현할 수 있다.
// 
// 6. 개발할 때, 상태 내역 사이를 오가고 액션 내역에서 현재 상태를 다시 계산하는 일을 TDD 스타일로 할 수 있다.
// 
// 7. 개발자 도구가 완전한 조사, 제어를 할 수 있게 함으로써 개발자들이 자신의 앱을 위한 도구를 직접 만들 수 있게 해준다.
// 
// 8. 비즈니스 로직을 대부분 재사용하면서 UI를 변경할 수 있게 한다. 

//* React Query *
// 사실 이건 전역 상태관리 라이브러리 보단 서버와 클라이언트 간 비동기 작업을 쉽게 다룰 수 있게 도와주는 라이브러리다.
// Redux 와 달리 서버상태에 대해서 절 적용한다

// 공식 문서에 따르면, 서버 상태는 다음과 같은 특징을 가진다고 설명한다. (백엔드 Database에 저장된 데이터라고 생각하면 편하다.)
// 
// - 어플리케이션 내에 속하지 않고, 그러므로 제어하지도 못한다. 보통은 원격에 위치한 곳에 저장되어있다. 
// 
// - 데이터를 가져오거나 업데이트를 하기 위해서는 비동기 API가 필요하다. 
// 
// - 나만 사용하는 것이 아니라, 다른 사람들과 함께 사용하기 때문에 언제 어떻게 Update 될 지 모른다.
// 
// - 그러므로 내가 당장 어플리케이션에서 사용하는 데이터가 Outdated 상태가 될 수 있다. 
// 
//   (클라이언트는 서버 데이터의 snapshot만을 사용하기 때문에, 클라이언트에서 보이는 서버 데이터는 항상 최신이라고 보장할 수 없다.)

// React Query는 useQuery hook의 파라미터를 통해 다양한 기능을 제어할 수 있다.
// 
// - API 데이터의 만료시간
// 
// - 데이터를 캐시에서 유지할 시간
// 
// - 브라우저를 focus할 때, 데이터를 리프레시 할 것인지에 대한 여부
// 
// - 리프레시 간격
// 
// - 데이터 가져오는 것에 대한 성공, 로딩, 에러 콜백 등..
// 
// 몇가지 기능들을 주절주절 적어봤지만, 뭐.. 정리하자면 데이터 Fetch, Load, Caching 등의 귀찮은 기능들을 모두 제공한다는거다. 
// 
// 정말 간단한 코드 몇줄로 이게 모두 가능하다. 
// 
//  
// 
// 이외에도 useMutation hook을 사용해 원격 데이터를 생성하거나 업데이트, 삭제하는 등의 기능도 편하게 사용할 수 있다. 정말 다양한 기능이 있으니 공식 문서를 꼭 살펴보면 좋을 것 같다. 
// 
// 사용 방법에 대해서는, 아래 블로그들을 참고해보시는 것도 좋을 것 같고, 실제 서비스 단에서 어떻게 사용하는지에 대해서는 우아한형제들 기술블로그에 있는 Store에서 비동기통신 분리하기 포스팅을 참고해보아도 좋을 것 같다. 